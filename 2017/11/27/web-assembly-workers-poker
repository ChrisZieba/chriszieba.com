<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>WebAssembly, Web Workers, and Poker</title>
  <meta name="description" content="Blackjack Probabilities">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
  <link rel="stylesheet" href="site.css">
</head>
<body>

<div id="header" class="outer">
  <div class="container inner">
    <div class="row">
      <div class="col-md-12">
        
        <h1 class="project-title">WebAssembly, Web Workers, and Poker</h1>
        <p class="post">Posted <time>November 27 2017</time> by <a href="http://chriszieba.com" title="Chris Zieba">Chris Zieba</a></p>
      </div>
    </div>
  </div>
</div>

<div class="container">

  <div class="row">
    <div class="col-md-12">
      
      <p>I recently spent a weekend to learn more about an exciting new web technology called WebAssebly, and built a <a>texas holdem hand simulatro</a>


      WebAssembly is a new binary format for executing code on the web, allowing for much faster start times. If you're not familiar with the concepts of WebAssembly, I would start here for an excellent primer: https://developer.mozilla.org/en-US/docs/WebAssembly.

      </p>

      <h2>Setup</h2>

      Setting up the emscripten sdk is very simple. The instructions here are gerat: https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html

      You should now be able to run `emcc` on your command line. 

      <p></p>

      As of right now there is a good amount of "glue" code required for JavaScript and compiled web asseml;y modules to speak to eachother.For a simple poker hand simulator, the needed JavaScript that emcc bbuilt was about 150kb minified.  

      Comiling the c++ code to web assembly is pretty easy with emcc.

      <code>
        
        emcc sim.cpp -O3 -s WASM=1 -s EXPORTED_FUNCTIONS="['_run']" -o sim.js
      </code>

      <span>EXPORTED_FUNCTIONS</span> lists the methods we'd like to access from JavaScript. Note that these names are from the source, with a prefixed underscore.

      This command will put compile the c++ code to wasm and generate the JavaScript glue code. This is required to set up the resizable ArrayBuffer that contains the linear array of bytes read and written by WebAssembly’s lowlevel memory access instructions. Without you will need to do this yourself which becomes a little bit tricky if you want to support multiple platforms.

      You may run into errors likethis

      failed to compile wasm module: LinkError: WebAssembly.Instance(): Import #12 module="env" function="___syscall221" error: function import requires a callable

      <code>
        
        const memory = new WebAssembly.Memory({initial: 0, maximum: 12});
        const env = {
          'abortStackOverflow': _ => { throw new Error('overflow'); },
          'table': new WebAssembly.Table({initial: 0, element: 'anyfunc'}),
          'tableBase': 0,
          'memory': memory,
          'memoryBase': 1024,
          'STACKTOP': 0,
          'STACK_MAX': memory.buffer.byteLength,
          'DYNAMICTOP_PTR': 1000,
          '___dso_handle': 1000,
          'abort': function(){},
          '_abort': function(){},
          'enlargeMemory': function() {},
          'getTotalMemory': function() {},
          'abortOnCannotGrowMemory': function() {},
          '___syscall221': function() {},
          '___cxa_atexit': function() {},
          '___syscall3': function() {},
          '___lock': function() {},
          '___syscall6': function() {}},
          '___setErrNo':function() {},
          '___unlock': function() {},
          '___syscall5': function() {},
          '_emscripten_memcpy_big': function() {},
          '___syscall54': function() {},
          '___syscall140':function() {},
          '___syscall146':function() {},


        };
        const importObject = {env};
        var myInstance = new WebAssembly.Instance(mod, importObject);
        console.log(myInstance)
      </code>
      </p>

      codelab has a great guide on how to build with only this option: https://codelabs.developers.google.com/codelabs/web-assembly-intro/index.html?index=..%2F..%2Findex#2
      Writing a standalone module without emscrpten glue JS can be a little tricky. When you compile C/C++ normally, you link with the system to provide implementations of the standard library methods your code uses.

JavaScript doesn't have these methods—either not with the same signatures or names (e.g, Math.atan in JavaScript vs atan in C), or because it's conceptually different (think malloc vs JavaScript's objects and garbage collection)—so Emscripten has to provide them for you.

    <code>ONLY_MY_CODE</code>

      Simulating poker hands can be split into different threads using web workers. The worker code is fairly straightforward. We extend the genreated module libarry to decalre handle any calls from our c++ code and 

      <code>
        let Simulate;
        onmessage = function(e) {
          const mod = e.data;

          Simulate(mod[0], mod[1], mod[2], mod[3], mod[4], simCount); // Pass the data into the C++ method
        };

        // Overrides for the generated emcc script, module gets redifined later
        let Module = {
          cc: function(data) {
            // This is the method that gets called from within our c+= module
          },

          onRuntimeInitialized: function() {
            // This corresponds to the EXPORTED_FUNCTIONS command from emcc
            Simulate = Module.cwrap('run', 'number', ['array', 'array', 'number', 'array', 'number','number']);
          }
        };

        // This loads the wasm generated glue code
        importScripts("sim.js");
      </code>

      In order to pass information back to our JavaScript worker we can use the EM_ESM c

      <code>
        
        // This calls the JavaScript worker which in turn calls postMessage with the data back to the main thread
        EM_ASM({
          Module.cc([$0]);
        }, totalSimulations);
      </code>

      In order to use this in your code you need to include the emscripten header <span>#include <emscripten.h></span>. For more information <a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code-call-javascript-from-native">see here</a>.
    </div>





  </div>

</div>

  <script type="text/javascript">
    var sc_project=9447020; 
    var sc_invisible=1; 
    var sc_security="3ecc64a0"; 
    var scJsHost = (("https:" == document.location.protocol) ? "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='"+scJsHost+"statcounter.com/counter/counter.js'></"+"script>");
  </script>
</body>
</html>
